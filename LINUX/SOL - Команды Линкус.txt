Команды

<команда> --help    справка по команде

cd   change dir

ls   list files
     -l   detailed или команда vdir
     -a   all files
     -F   file types
     -ld  with permissions and owner

* - для выполняемых файлов, слэш - для каталогов, знак '@' - для ссылок, 
знак '=' - для сокетов, знак '-' - для символьных устройств, 
знак '+' - для блочных устройств, знак '|' - для каналов данных, 
знак '~' - для символических ссылок к каталогам и 
восклицательный знак для пустых символических ссылок (ссылок, которые ни на что не указывают). 

синий - директория, лазурный - симв. ссылка, зелёный - исполняемый

cp [opt] <from> <to>   copy files
   -i   interactive
   -r   recursive - with subdirs

mv [opt] <from> <to>   move files

mkdir <name>   make dir

rm <name>      remove (delete) file
rm -r <name>   remove dir
rm -rf <name>  remove dir without questions
rmdir <name>   remove empty dir

users, groups, id   # вывод информации о ...
who, w              # кто онлайн
last, lastlog       # кто был
uptime

uname -a            # данные о системе
lsof                # список открытых файлов

useradd, userdel, passwd # управление пользователями

chown [OPTION]... [OWNER][:[GROUP]] FILE...   change owner
   -R    recursive

сhgrp   # change group

chmod <owner_group_other> <file>   change permission
      read=4 + write=2 + execute=1

sudo      # запуск команды от root
su        # запуск оболочки от root
su <user> # от user


locate <file>   search file in base
find <file>     search file on disk
readlink <file> получение имени из ссылки

find "/home/junk" -type f -atime +5 -exec rm {} \;
Удалить все файлы в каталоге к которым не было обращений в течение последних 5 дней.


find /path/to/files* -mtime +5 -exec rm {} \;

удалить файлы старее 5 дней (дата модификации старее)

updatedb   upd db for locate

date

touch <file>  create empty file

cat <file1> <file2> concatenate files and output to console

cat <file1> <file2> > <file3> output to file3 (overwrites)

                    >> append to file

cat <file> output file to console
cat > <file> write text input to file

tar –czvf myfiles.tar.gz myfiles   Create Zip Verbose toFile
tar –xzvf myfiles.tar.gz           eXtract Zip Verbose fromFile
tar -tvf  myfiles.tar.gz           список файлов в архиве

gzip <file>       # архивирует только один файл, после архивации исходный удаляет
gunzip <file>     # после разархивации архив удаляет

cat <file>    view content

cat /dev/nul > <file>  to make file empty

cat <f1> <f2> > <f3>  to copy files f1 f2 to f3
tac                   to copy files in reverse

less <file>   view content with scroll  Q - for quit.

grep [opt] <word> <dir/files>  search word or "string" in files
     -R   in sub dirs
     -i   ignore case
     -l   output only file names

если файл не задан grep работает с конвейером

du [opt] <dir>   disk usage (list dirs)
   -h    human readable
   -s    only summarized

df  total space on disk 
df -h свободное место на диске

stat <file>     # подробная инфо о файле

<arg1> .. <argN> xargs <команда>  запускает команду N раз, с каждым аргументом

ls | xargs -l gzip  # перенести в архив каждый файл в директории

sort  сортировка потока, -nr по убыв.

uniq  удаление повторяющихся строк, -c количество повторов

sort INPUTFILE | uniq -c | sort -nr  # выводит статистику встречаемости строк в файле

expand  преобразование табуляции в пробелы, unexpand наборот

tail <file> выводит последние 10 строк файла

wc <file>  "word count", счетчик слов в файле или в потоке:

   -w подсчитывает только слова.
   -l подсчитывает только строки.
   -c подсчитывает только символы.
   -L возвращает длину наибольшей строки.

tr "A-Z" "*"         # замена одних символов на другие
tr -d 0-9 <filename  # удаление цифр в файле
tr -s ' '            # сожмёт все повторяющиеся символы до одного
tr -c A-F *          # замена символов, кроме тех, что в шаблоне 

CR='\015'            # Возврат каретки.
tr -d $CR < $INFILE > $OUTFILE   # Удалить символы CR и записать в новый файл.

rpm -qa [имя]      # список установленных пакетов (или пакетов содержащих имя...)

yum provides "nslookup" # поиск пакета с утилитой

diff -Naur <file1> <file2> >patch.txt  # создание файла различий
patch <file1> patch.txt                # правка файла 1 до состояния файла 2

СЕТЬ

hostname
host <имя>
nslookup <ip>
traceroute <ip>
ip addr            # посмотреть конфиг сетевых
ssh -p <port> <ip>
nmap <ip>          # скан портов
netstat -tulpan    # активные соединения
route              # маршруты
ifconfig           # настройка сети

Метрика - числовое значение, влияющее на выбор маршрута в компьютерных сетях. Иными словами это число переходов (скачков) до места назначения. В ОС семейства Linux не стоит уделять много внимания метрике, т. к. метрика в маршрутах - только для протоколов маршрутизации. При выборе маршрута ядро игнорирует метрику. 

free, vmstat       # использование памяти
lsdev              # список устройств
ps ax              # процессов статистика
top                # cписок наиболее активных процессов и нагрузка проца -b обычным текстом
pidof <имя процесса> 
kill <ид процессса>
fuser <file>       # возвращает идентификаторы процессов, использующих указанный файл(ы) или каталог. 
                   # с ключом -k, завершает найденные процессы

systemctl status firewalld # проверить запущена ли служба                   


=====================================================================================================
BASH script

в первой строке файла должно быть #!/bin/bash
у файла сделать атрибут X - исполняемый
запуск ./имяфайла.sh

|   конвейер. Передает вывод предыдущей команды на ввод следующей 

---------------

Имя файла со скриптом

if [ -z "$1" ]
then
  echo "Порядок использования: `basename $0` параметр"
  exit $E_NOARGS
fi

---------------

if [ $# -eq 0 ] 
then
  echo "Вызовите сценарий с одним или более параметром командной строки."
  exit 1
fi

errorlevel в переменной $? её можно анализировать после выполнения команды, -eq 0 в случае успеха
---------------

Вывод блока кода в файл

{
...
} > /fff.txt

---------------

$? результат выполнения команды
$$ pid процесса

---------------

расширение файла ${filename##*.}

rm .[A-Za-z0-9]*    # удалить "скрытые" файлы (начинающиеся с ".")

---------------

Позиционные параметры (аргументы)

$0, $1, $2 и т.д. аргументы передаются из командной строки в сценарий, функциям или команде set
$#  количество аргументов командной строки
$*  все аргументы в виде одной строки (слова)
$@  то же самое, что и $*, но при этом каждый параметр представлен как отдельная строка (слово)

-------------
соединение строк

c="$a$b"
c="${a}${b}"    # так надёжнее
c="$a${b}text"  # добавка текста  
c="$a/$b/"      # символы / и др. можно просто так добавлять

длина строки

${#c}

let d=${#c}-1  # вычесть из длины 1

поиск подстроки

echo `expr index "$c" abc`  # номер позиции, начиная с 1 или 0

извлечение подстроки

${string:position}          # позиция считается с 0
${string:position:length}
${string: -position:length} # извл. с конца, позиция считается с -1

${*:3}                      # извл. 3-го и последующих параметров из ком строки
${*:3:1}                    # извл. 3-го параметра из ком строки

удаление подстроки

${string/substring}         # удаление первого вхождение подстроки
${string//substring}        # удаление всех вхождений подстрок

${string#sub}               # удаление подстроки, если строка начинается с подстроки
${string%sub}               # удаление подстроки, если строка заканчивается подстрокой

если подстрока шаблон, то по # или % удаляется самое короткое совпадение,
по ## или %% самое длинное

${string/substring/replace} # замена подстроки на...

${string/#substring/replace} # замена подстроки на..., если строка начинается с подстроки
${string/%substring/replace} # замена подстроки на..., если строка заканчивается подстрокой

-------------
задание значения для параметра/переменной по умолчанию

${username-`whoami`}       # возвращает результат команды, если переменная пустая
${num-3}                   # возвращает число 3, если num пустая, переменная остаётся пустой

${num:=3}                  # присваивает переменной значение по умолчанию

-------------

FILEPATH=/home/dir/file.ext
echo ${FILEPATH##/*/}     # оставит только файл
echo ${FILEPATH%/*.*}     # оставит только путь (работает если файл с расширением)

-------------

(( a++ ))                 # работа с переменными в стиле Си

-------------
Массивы

arr[1]=123                # нумерация элементов может быть с пропусками
arr2=( нулевой первый \   # инициализация массива списком
       второй )           
arr3=([17]=семнадцать \   # можно задать номера элементов
      [21]=двадцать_один) 
declare -a arr4           # можно так объявить массив

read -a arr4             # ввод значений через пробел
${#arr4[*]}              # количество элементов
${arr4[*]}		 # вывод элементов

echo ${arr[1]}

arr=( "${arr[@]}" "новый1" ) # добавление элемента

arr=( `cat "$filename" | tr '\n' ' '`)  # Загрузка содержимого файла


-------------

ЦИКЛЫ

перебор файлов в директории

for FN in * или for FN in *.txt
do
  echo ${FN%.txt}  # удаление расширения .txt
done

-------------

for ARG in "$var1" "$var2" "$var3" ... "$varN"

-------------

цикл по набору параметров

for planet in "Меркурий 36" "Венера 67" "Земля 93"
do
  set -- $planet  # Разбиение переменной "planet" на множество аргументов
  echo "$1      в $2,000,000 миль от Солнца"
done

-------------

Если [список] в цикле for не задан, то в качестве оного используется переменная $@ -- список аргументов командной строки

-------------

for ((a=1; a <= LIMIT; a++))   # Сишный вариант цикла

-------------
Условные циклы

while [ "$var0" -lt "$LIMIT" ]
while (( a <= LIMIT ))
until [ "$var1" = end ]            # выполняется, если условие ложно, вычисляется в начале итерации

break, continue  без параметра прерывают, продолжают текущий цикл, с параметром равным 2 ещё и цикл на уровень выше

------------
Ветвления

if [ condition1 ]
then
  if [ condition2 ]
  then
    do-something  
  fi
fi

case "$Keypress" in
  [a-z,A-Z] ) echo "Буква";;
  [0-9]     ) echo "Цифра";;
  *         ) echo "Другое";;
esac 

-------------

В условиях:

=    проверка равенства строк 
-eq  проверка равенства чисел

-------------

Меню

PS3='Выберите... ' 

echo

select vegetable in "бобы" "морковь" "картофель" "лук" "брюква"
do
  echo
  echo "Вы предпочитаете $vegetable."
  echo
  break 
done

-------------
ввод значений

read var1  # по умолчанию ввод в переменную $REPLY

read -s -n1 -p "Нажмите клавишу " var1 # завршение ввода после нажатия первой клавиши

чтение файла (в конце последней строки должен быть перевод на новую)

while read line
do
  echo "$line"
done <data-file

-------------

set `команда` # меняет значение переменных сценария $1 $2 ... на то, что выдаст команда после её исполнения

-------------

echo `ls -l`    # выведет в одну строку результат
echo "`ls -l`"  # в несколько строк
echo -n         # подавление переноса строк

------------

подключение файлов c переменными или функциями в скрипт

. ./somefile

------------
exec   # заменяет текущий процесс новым процессом, запускаемым командой exec, текущий скрипт завершается

wait   # Останавливает работу сценария до тех пор пока не будут завершены все фоновые задания 

sleep <N> # Ожидание N секунд

yes | <команда>  # для запуска чего-либо без вопросов

Объединение команд
<ком1> && <ком2>   # ком2 выполнится, если ком1 успешно
<ком1> || <ком2>   # ком2 выполнится, если ком1 не успешно

-------------
/etc/profile       # настройки системы по-умолчанию
/etc/bashrc        # функции и псевдонимы Bash

/dev/null          # черная дыра

-------------
Регулярные выражения

к имени файла можно добавить фигурные скобки файл{1,2,3}, команда обработает файл1, файл2, файл3
{a..c}-{1..3} будет множество файлов a1 a2 a3 b1 ... c3

abc*  означает, что после ab может быть любое количество букв с
abc?  одна или ноль букв перед ?


-------------

дата время в имени файла

имя_файла_$(date +%Y-%m-%d:%k:%M:%S)
 
--------------------------
список заданий планировщика
смотреть
crontab -l
редактировать
crontab -e

# Бекап каждый час
0 */1 * * * /home/user/kipishclub/scripts/backup_db.sh

# Бекап раз в сутки
#0 21 * * * /home/user/kipishclub/scripts/backup_db.sh

# Перенос заархивированных логов в папку для логов
0 */3 * * * /home/user/kipishclub/scripts/move_logs.sh

# Копирование бэкапов на резервный сервер
0 9 * * * /home/user/kipishclub/scripts/copy_dumps.sh


 0 */3 * * * find /home/user/kipishclub/backups/backup_db*.gz -mtime +2 -exec rm {} \;


------------------------------------------------

ubuntu:
-------
перезагрузка службы (сервиса)
service postgresql reload


Просмотр правил 

sudo iptables -L

Если в iptables уже есть какие-либо правила и вы хотите их удалить просто выполните:

sudo iptables -F

Теперь нам нужно добавить правила, которые разрешат обмен данными между любыми портами на локальном интерфейсе lo, это нужно чтобы не вызвать системных ошибок:

sudo iptables -A INPUT -i lo -j ACCEPT
sudo iptables -A OUTPUT -o lo -j ACCEPT




Закрыть порт

 sudo iptables -A INPUT -p tcp --dport 15672 -j DROP

 sudo iptables -I INPUT -p tcp --dport 15672 -m state --state NEW -j ACCEPT


-----------------------------------

screen -x список экранов
screen -r 1234 подключиться к экрану 1234
ctrl-A отпустить потом d - отключиться от экрана (когда клавиатура на РУС - не работает!)
ctrl-A k убить экран или exit в нём

screen -d экран  принудительное отключение от экрана

запуск нового экрана screen -S имяскрина

освободить порт, если приложение завершилось некорректно и не освободило порт
fuser 8095/tcp -k

убил скрин ctrl-a k потом создал его screen -S rabbit и в нем порт освободил fuser 8092/tcp -k